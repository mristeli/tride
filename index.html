<html>
<head>
<script type="text/javascript" src="objects.js"></script>
<script type="text/javascript" src="extension.js"></script>
<script type="text/javascript">
	
	function multiplyMatrixVector(v, mat) {
		const x = v.x * mat[0] + v.y * mat[4] + v.z * mat[8] + mat[12];
		const y = v.x * mat[1] + v.y * mat[5] + v.z * mat[9] + mat[13];
		const z = v.x * mat[2] + v.y * mat[6] + v.z * mat[10] + mat[14];
		const w = v.x * mat[3] + v.y * mat[7] + v.z * mat[11] + mat[15];
		if(w != 0 && w != 1) {
			return new Vector(x / w, y / w, z / w);
		}
		return new Vector(x, y, z);
	}

	function initializeEngine(canv) {
		const sceneSettings = function(run = false, inc = 0.01, change = 0.03) {	
			this.isRunning = function() {
				return run;
			}
			this.toggleRunning = function() {
				run = !run;
			}
			this.getInc = function() {
				return inc;
			}
			this.increseInc = function() {
				inc += change;
			}
			this.reduceInc = function() {
				inc -= change;
			}
			this.cameraLeft = function() {
				camera[0].x -= 0.1;
			}
			this.cameraRight = function() {
				camera[0].x += 0.1;
			}
			this.cameraDown = function() {
				camera[0].y -= 0.1;
			}
			this.cameraUp = function() {
				camera[0].y += 0.1;
			}
			this.cameraIn = function() {
				camera[1].z += 0.5;
			}
			this.cameraOut = function() {
				camera[1].z -= 0.5;
			}
			this.turnCamera = function(dir) {
				var d = (dir * Math.PI / 30)
				var cam_cos = Math.cos(d), cam_sin = Math.sin(d);
				return function() {
					const matCamRot = [
						cam_cos, 0, - cam_sin, 0,
						0, 1, 0, 0,
						cam_sin, 0, cam_cos, 0,
						0, 0, 0, 0
					]
					camera[0] = multiplyMatrixVector(camera[0], matCamRot);
					camera[2] = camera[2] - d;
					if(camera[2] < 0) {
						camera[2] += 2*Math.PI;
					} else if (camera[2] > 2*Math.PI) {
						camera[2] -= 2*Math.PI;
					}
					// console.log('cam x y z {0},{1},{2}'.format(camera[0].x, camera[0].y,
						// camera[0].z));
				}
			}
			return this;
		}();
	
		const ops = { 
				32 : sceneSettings.toggleRunning,
				38 : sceneSettings.increseInc,
				40 : sceneSettings.reduceInc,
				65 : sceneSettings.cameraLeft,
				68 : sceneSettings.cameraRight,
				70 : sceneSettings.cameraDown,
				82 : sceneSettings.cameraUp,
				83 : sceneSettings.cameraOut,
				87 : sceneSettings.cameraIn,
				69 : sceneSettings.turnCamera(-1), 
				81 : sceneSettings.turnCamera(1)
			}

		document.addEventListener('keydown', function(e) {
			if(!e) e = window.event;
			if(e.keyCode in ops) ops[e.keyCode]();
			else console.log('key ' + e.keyCode);
		});

		setInterval(function(settings) {
			if(settings.isRunning()) {
				angle += settings.getInc();
				if(angle > Math.PI * 6) angle -= Math.PI * 6;
			}
		}, 50, sceneSettings);
		renderScene(canv, sceneSettings);
	}
	
	var fps = (function() {
		var times = [];
		return function() {
			const now = performance.now();
  	    	while (times.length > 0 && times[0] <= now - 1000) {
  	    		times.shift();
			}
  	  times.push(now);
			return times.length;
		}
	})();
	
	const zNear = 0.1;
	const zFar = 100;
	const fov = 90;
	
	const fovRad = 1.0 / Math.tan(fov * Math.PI / 180 / 2);
	const q = zFar / ( zFar - zNear );
	
	var angle = 0;
	
	// pos_vec, dir_vec
	var camera = [new Vector(0, 0, -25),
		new Vector(0, 0, -25), 0];
	var lightPole = new Vector(10, 0, 5)

	var animationFrame;

	function toHex(c) {
	 	return c.toString(16).padStart(2, '0');
	}
	
	const v_screen_cam = new Vector(0, 0, -5);

	function brightness(tri, camera, obj) {
		const reverse_angle = camera[2] > Math.PI / 2 && camera[2] < 3*Math.PI / 2; 
		const tri_loc_wo_y = new Vector(tri.v1.x, 0, tri.v1.z);
		const cam_vec = v_screen_cam.dirVecFrom(tri_loc_wo_y).normalize()
		var brightness = reverse_angle ? 
			tri.normal.dot(cam_vec) : 
			cam_vec.dot(tri.normal);

		// // console.log('obj {0} light {1}'.format(obj.name, brightness));
		return brightness < 0.3 ? 0.3 : brightness;
	}

	function getObjectsForRender() {
		return scene//.filter(obj => obj.pos.z > camera[0].z)
			.sort((_o1, _o2) => 
					_o2.pos.dirVecFrom(camera[0]).length - 
						_o1.pos.dirVecFrom(camera[0]).length 
				)
	}

	function renderScene(canv, sceneSettings) {
		var context = canv.getContext("2d");
		context.fillStyle = "#000000";
		context.fillRect(0, 0, canv.width, canv.height);
		
		const aspectRatio = canv.height / canv.width;
		
		const rotZ = angle/3;
		const rotX = angle;  
		
		const cos = Math.cos(rotX);
		const sin = Math.sin(rotX); 
		
		const cos2 = Math.cos(rotZ);
		const sin2 = Math.sin(rotZ);
				
		const matProj = [ 
			aspectRatio * fovRad, 0, 0, 0, 
			0, -fovRad, 0, 0,
		  1, 1, q, 1,
			0, 0, - q * zNear, 0
		];
	
		context.lineWidth = 1;
	
		cam_cos = Math.cos(camera[2]); 
		cam_sin = Math.sin(camera[2]);

		const matCamRot = [
				cam_cos, 0, - cam_sin, 0,
				0, 1, 0, 0,
				cam_sin, 0, cam_cos, 0,
				//  - camera[0].x, - camera[0].y, - camera[0].z, 1
				0, 0, - camera[1].z, 1
			]

		getObjectsForRender()
			.forEach(function(obj) {
				var mesh = obj["mesh"];
				const pos = obj["pos"];
				const matRotTrans = [
					cos2, - sin2 * cos, sin * sin2, 0,
					sin2, cos * cos2, cos2 * (- sin), 0,
					0, sin, cos, 0,
					//pos[0] - camera[0].x, pos[1] - camera[0].y, pos[2] - camera[0].z, 1
					0, 0, 0, 1
				];
			
				mesh = mesh
					.matrixMultiply(matCamRot)
					.matrixMultiply(matRotTrans)

				mesh.tris.forEach(function(tri) {
					var b = brightness(tri, camera, obj)
					if(b < 0) b = 0;
					tri.fillStyle = "#{0}{1}{2}".format(
						toHex(Math.floor(obj.col[0] * b)), 
						toHex(Math.floor(obj.col[1] * b)), 
						toHex(Math.floor(obj.col[2] * b))
					);
				});

				mesh = mesh
					.matrixMultiply(matProj)
					.filterNotvisible()
			
				mesh.tris.forEach(function(tri) {		
					context.fillStyle = tri.fillStyle;
					context.strokeStyle = tri.fillStyle;
					
					tri.v1.x *= canv.width / 2;	tri.v1.y *= canv.height / 2;
					tri.v2.x *= canv.width / 2; tri.v2.y *= canv.height / 2; 
					tri.v3.x *= canv.width / 2; tri.v3.y *= canv.height / 2;
					
					context.beginPath();
					context.moveTo(tri.v1.x, tri.v1.y);			
					context.lineTo(tri.v2.x, tri.v2.y);
					context.lineTo(tri.v3.x, tri.v3.y);
					context.closePath();
					context.fill();
					context.stroke();	
				});
		})

		context.fillStyle = "#FFFFFF";		
		context.font = "12px Arial";
		context.fillText("FPS " + fps(), 5, 12);
		context.fillText("INC " + sceneSettings.getInc().toFixed(4), 5, 30);
		context.fillText("CAM x: {0} y: {1} z: {2} angle: {3}"
			.format(camera[0].x, camera[0].y, camera[0].z, camera[2]), 5, 48);

		animationFrame = requestAnimationFrame(
			() => renderScene(canv, sceneSettings)
		)
	}
	
	function Vector(_x, _y, _z) {
		this.x = _x;
		this.y = _y;
		this.z = _z;
	
		this.length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	Vector.prototype.dirVecFrom = function(other) {
		return new Vector(this.x - other.x, this.y - other.y, this.z - other.z);
	}
	Vector.prototype.cross = function(other) {
		return new Vector(this.y * other.z - this.z * other.y, 
			this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);
	}
	Vector.prototype.dot = function(other) {
		return this.x * other.x + this.y * other.y 
				+ this.z * other.z;
	}
	Vector.prototype.normalize = function() {
		return new Vector(this.x / this.length, this.y / this.length, this.z / this.length);
	}
	Vector.prototype.translate = function(i, j = 0, k = 0) {
		return new Vector(this.x + i, this.y + j, this.z + k);
	}
	
	function Triangle (_v1, _v2, _v3) {
		this.v1 = _v1;
		this.v2 = _v2;
		this.v3 = _v3;
		
		this.normal = this.v2.dirVecFrom(this.v1).cross(this.v3.dirVecFrom(this.v1)).normalize();
	}
	Triangle.prototype.scale = function(r) {
		return new Triangle(new Vector(this.v1.x * r, this.v1.y * r, this.v1.z * r), 
			new Vector(this.v2.x * r, this.v2.y * r, this.v2.z * r),
			new Vector(this.v3.x * r, this.v3.y * r, this.v3.z * r));
	}
	Triangle.prototype.translate = function(i, j = 0, k = 0) {
		return new Triangle(this.v1.translate(i, j, k), 
			this.v2.translate(i, j, k), 
			this.v3.translate(i, j, k));
	}
	
	function Mesh (tris) {
		this.tris = tris;	
	}
	Mesh.prototype.scale = function(r) {
		return new Mesh(this.tris.map(tri => tri.scale(r)));
	}
	Mesh.prototype.translate = function(i, j, k) {
		return new Mesh(this.tris.map(tri => tri.translate(i, j, k)));
	}
	Mesh.prototype.filterNotvisible = function() {
		const neg = (camera[2] > Math.PI / 2 && camera[2] < 3*Math.PI / 2)  
		return new Mesh(this.tris.filter(tri => {
			const dot_prod = tri.v1.dirVecFrom(camera[1]).dot(tri.normal)
			return dot_prod >= 0
		}))
	}
	Mesh.prototype.matrixMultiply = function(matrix) {
		return new Mesh(this.tris.map(
			tri => {
				ret = new Triangle(
					multiplyMatrixVector(tri.v1, matrix),
					multiplyMatrixVector(tri.v2, matrix),
					multiplyMatrixVector(tri.v3, matrix))
				ret.fillStyle = tri.fillStyle;
				return ret;
			}));
	}

	// Translate meshes to world coordinates
	function compileScene(_scene) {
		return _scene.map(_o => Object.assign(_o, {
			"mesh" : _o.mesh.translate(
					_o.pos.x, _o.pos.y, _o.pos.z
			).scale(_o.size)
		}));
	}

	const objects = getObjects();
	const sceneDef = [
	/*		{
				"name" : "plane",
				"mesh" : objects["plane"],
				"size" : 10000000000,
				"pos" : new Vector(0, -15, 20),
				"col" : [255, 255, 255]
			},
			{ 
				"name" : "red",
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : new Vector(0, -15, 20),
				"col" : [255, 00, 0]
			},*/
			{
				"name" : "green",
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : new Vector(0, 0, 0),
				"col" : [0, 255, 10]
			},
			{
				"name" : "brown",
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : new Vector(-2, 0, -5), 
				"col" : [200, 100, 0]
			},
			{ 
				"name" : "blue",
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : new Vector(2, 0, -5),
				"col" : [0, 0, 200]
			},
			{
				"name" : "violet",
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : new Vector(2, 2, -5),
				"col" : [200, 0, 200]	
			}
		];
	const scene = compileScene(sceneDef);
	
</script>
<title>pure js 3d fun</title>
</head>
<body onload="initializeEngine(document.getElementById('view'))">
<canvas id="view" width="640" height="480" style="float: left;">
</canvas>
<div style="float: left;">
	<p>Camera control</p>
	<table>
		<tr>
			<td>a</td><td>Camera left</td>
		</tr>
		<tr>
			<td>d</td><td>Camera right</td>
		</tr>
		<tr>
			<td>w</td><td>Camera zoom in</td>
		</tr>
		<tr>
			<td>s</td><td>Camera zoom out</td>
		</tr>
		<tr>
			<td>q</td><td>Camera rotate left</td>
		</tr>
		<tr>
			<td>e</td><td>Camera rotate right</td>
		</tr>
	</table>
</div>
</body>
</html>