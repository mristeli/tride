<html>
<head>
<script type="text/javascript" src="objects.js"></script>
<script type="text/javascript" src="extension.js"></script>
<script type="text/javascript">
	
	function multiplyMatrixVector(v, mat) {
		const x = v.x * mat[0] + v.y * mat[4] + v.z * mat[8] + mat[12];
		const y = v.x * mat[1] + v.y * mat[5] + v.z * mat[9] + mat[13];
		const z = v.x * mat[2] + v.y * mat[6] + v.z * mat[10] + mat[14];
		const w = v.x * mat[3] + v.y * mat[7] + v.z * mat[11] + mat[15];
		if(w != 0 && w != 1) {
			return new Vector(x / w, y / w, z / w);
		}
		return new Vector(x, y, z);
	}

	function initializeEngine(canv) {
		const sceneSettings = function(run = false, inc = 0.01, change = 0.03) {	
			this.isRunning = function() {
				return run;
			}
			this.toggleRunning = function() {
				run = !run;
			}
			this.getInc = function() {
				return inc;
			}
			this.increseInc = function() {
				inc += change;
			}
			this.reduceInc = function() {
				inc -= change;
			}
			this.cameraLeft = function() {
				camera[0].x -= 0.1;
			}
			this.cameraRight = function() {
				camera[0].x += 0.1;
			}
			this.cameraDown = function() {
				camera[0].y -= 0.1;
			}
			this.cameraUp = function() {
				camera[0].y += 0.1;
			}
			this.cameraIn = function() {
				camera[0].z += 0.5;
			}
			this.cameraOut = function() {
				camera[0].z -= 0.5;
			}
			this.turnCamera = function(dir) {
				return function() {
					d = (dir * Math.PI / 100)
					cam_cos = Math.cos(d), cam_sin = Math.sin(d);
					const matCamRot = [
						cam_cos, 0, - cam_sin, 0,
						0, 1, 0, 0,
						cam_sin, 0, cam_cos, 0,
						0, 0, 0, 0
					]
					camera[0] = multiplyMatrixVector(camera[0], matCamRot);
					camrea[2] += d;
					console.log('cam x y z {0},{1},{2}'.format(camera[0].x, camera[0].y,
						camera[0].z));
				}
			}
			return this;
		}();
	
		const ops = { 
				32 : sceneSettings.toggleRunning,
				38 : sceneSettings.increseInc,
				40 : sceneSettings.reduceInc,
				65 : sceneSettings.cameraLeft,
				68 : sceneSettings.cameraRight,
				70 : sceneSettings.cameraDown,
				82 : sceneSettings.cameraUp,
				83 : sceneSettings.cameraOut,
				87 : sceneSettings.cameraIn,
				69 : sceneSettings.turnCamera(-1), 
				81 : sceneSettings.turnCamera(1)
			}

		document.addEventListener('keydown', function(e) {
			if(!e) e = window.event;
			if(e.keyCode in ops) ops[e.keyCode]();
			else console.log('key ' + e.keyCode);
		});

		setInterval(function(settings) {
			if(settings.isRunning()) {
				angle += settings.getInc();
				if(angle > Math.PI * 6) angle -= Math.PI * 6;
			}
		}, 50, sceneSettings);
		renderScene(canv, sceneSettings);
	}
	
	var fps = (function() {
		var times = [];
		return function() {
			const now = performance.now();
  	    	while (times.length > 0 && times[0] <= now - 1000) {
  	    		times.shift();
			}
  	  times.push(now);
			return times.length;
		}
	})();
	
	const zNear = 0.1;
	const zFar = 100;
	const fov = 90;
	
	const fovRad = 1.0 / Math.tan(fov * Math.PI / 180 / 2);
	const q = zFar / ( zFar - zNear );
	
	var angle = 0;
	
	// pos_vec, dir_vec
	var camera = [new Vector(0, 0, -15),
		new Vector(0, 0, 1.0), 0];

	var animationFrame;

	function toHex(c) {
	 	return c.toString(16).padStart(2, '0');
	}

	function fillColor(tri, camera, obj) {
		const pos = new Vector(obj.pos[0] - camera[0].x, 
			obj.pos[1] - camera[0].y, obj.pos[2] - camera[0].z).normalize();
		light = -tri.normal.dot(pos);
		r = obj.col[0], g = obj.col[1], b = obj.col[2];
		r = Math.floor(r * light), g = Math.floor(g * light), b = Math.floor(b * light);
		return "#{0}{1}{2}".format(toHex(r), toHex(g), toHex(b));
	}

	function renderScene(canv, sceneSettings) {
		var context = canv.getContext("2d");
		var scene = [
			{
				"mesh" : objects["plane"],
				"size" : 80,
				"pos" : [0, -30, 40],
				"col" : [255, 255, 255]
			},
			{ 
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : [0, -15, 30],
				"col" : [255, 00, 0]
			},
			{
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : [0, 0, 10],
				"col" : [0, 255, 10]
			},
			{
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : [-2, 0, 5], 
				"col" : [200, 100, 0]
			},
			{ 
				"mesh" : objects["cube2"],
			  "size" : 1,
				"pos" : [2, 0, 5],
				"col" : [0, 0, 200]
			}
		];

		context.fillStyle = "#000000";
		context.fillRect(0, 0, canv.width, canv.height);
		
		const aspectRatio = canv.height / canv.width;
		
		const rotZ = angle/3;
		const rotX = angle;  
		
		const cos = Math.cos(rotX);
		const sin = Math.sin(rotX); 
		
		const cos2 = Math.cos(rotZ);
		const sin2 = Math.sin(rotZ);
				
		const matProj = [ 
			aspectRatio * fovRad, 0, 0, 0, 
			0, -fovRad, 0, 0,
		  	1, 1, q, 1,
			0, 0, - q * zNear, 0
		];
	
		context.lineWidth = 1;
	
		cam_cos = Math.cos(camera[2]); 
		cam_sin = Math.sin(camera[2]);

		const matCamRot = [
				cam_cos, 0, - cam_sin, 0,
				0, 1, 0, 0,
				- cam_sin, 0, cam_cos, 0,
				0, 0, 0, 0
			]

		scene.forEach(function(obj) {
			var mesh = obj["mesh"];
			mesh = mesh.scale(obj["size"])
			const pos = obj["pos"];
			const matRotTrans = [
				cos2, - sin2 * cos, sin * sin2, 0,
				sin2, cos * cos2, cos2 * (- sin), 0,
				0, sin, cos, 0,
				pos[0] - camera[0].x, pos[1] - camera[0].y, pos[2] - camera[0].z, 1
			];
		
			mesh = mesh.matrixMultiply(matRotTrans)
				.matrixMultiply(matCamRot)
			mesh.tris.forEach(function(tri) {
				tri.fillStyle = fillColor(tri, camera, obj)
			});

			mesh = mesh
				.matrixMultiply(matProj)
				.filterNotvisible();
		
			mesh.tris.forEach(function(tri) {				
				context.fillStyle = tri.fillStyle;
				context.strokeStyle = tri.fillStyle;
				
				tri.v1.x *= canv.width / 2;	tri.v1.y *= canv.height / 2;
				tri.v2.x *= canv.width / 2; tri.v2.y *= canv.height / 2; 
				tri.v3.x *= canv.width / 2; tri.v3.y *= canv.height / 2;
				
				context.beginPath();
				context.moveTo(tri.v1.x, tri.v1.y);			
				context.lineTo(tri.v2.x, tri.v2.y);
				context.lineTo(tri.v3.x, tri.v3.y);
				context.closePath();
				context.fill();
				context.stroke();	
			});
		})

		context.fillStyle = "#FFFFFF";		
		context.font = "12px Arial";
		context.fillText("FPS " + fps(), 5, 12);
		context.fillText("INC " + sceneSettings.getInc().toFixed(4), 5, 30);
		context.fillText("CAM x: {0} y: {1} z: {2} angle: {3}"
			.format(camera[0].x, camera[0].y, camera[0].z, camera[2]), 5, 48);

		animationFrame = requestAnimationFrame(
			() => renderScene(canv, sceneSettings)
		)
	}
	
	function Vector(_x, _y, _z) {
		this.x = _x;
		this.y = _y;
		this.z = _z;
	
		this.length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	Vector.prototype.dirVecFrom = function(other) {
		return new Vector(this.x - other.x, this.y - other.y, this.z - other.z);
	}
	Vector.prototype.cross = function(other) {
		return new Vector(this.y * other.z - this.z * other.y, 
			this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);
	}
	Vector.prototype.dot = function(other) {
		return this.x * other.x + this.y * other.y 
				+ this.z * other.z;
	}
	Vector.prototype.normalize = function() {
		return new Vector(this.x / this.length, this.y / this.length, this.z / this.length);
	}
	Vector.prototype.translate = function(i, j = 0, k = 0) {
		return new Vector(this.x + i, this.y + j, this.z + k);
	}
	
	function Triangle (_v1, _v2, _v3) {
		this.v1 = _v1;
		this.v2 = _v2;
		this.v3 = _v3;
		
		this.normal = this.v2.dirVecFrom(this.v1).cross(this.v3.dirVecFrom(this.v1)).normalize();
	}
	Triangle.prototype.scale = function(r) {
		return new Triangle(new Vector(this.v1.x * r, this.v1.y * r, this.v1.z * r), 
			new Vector(this.v2.x * r, this.v2.y * r, this.v2.z * r),
			new Vector(this.v3.x * r, this.v3.y * r, this.v3.z * r));
	}
	Triangle.prototype.translate = function(i, j = 0, k = 0) {
		return new Triangle(this.v1.translate(i, j, k), 
			this.v2.translate(i, j, k), 
			this.v3.translate(i, j, k));
	}
	
	function Mesh (tris) {
		this.tris = tris;	
	}
	Mesh.prototype.scale = function(r) {
		return new Mesh(this.tris.map(tri => tri.scale(r)));
	}
	Mesh.prototype.translate = function(i, j, k) {
		return new Mesh(this.tris.map(tri => tri.translate(i, j, k)));
	}
	Mesh.prototype.filterNotvisible = function() {
		return new Mesh(this.tris.filter(tri => tri.normal.z > 0.0))
	}
	Mesh.prototype.matrixMultiply = function(matrix) {
		return new Mesh(this.tris.map(
			tri => {
				ret = new Triangle(
					multiplyMatrixVector(tri.v1, matrix),
					multiplyMatrixVector(tri.v2, matrix),
					multiplyMatrixVector(tri.v3, matrix))
				ret.fillStyle = tri.fillStyle;
				return ret;
			}));
	}
	const objects = getObjects();
</script>
<title>pure js 3d fun</title>
</head>
<body onload="initializeEngine(document.getElementById('view'))">
<canvas id="view" width="640" height="480" style="float: left;">
</canvas>
<div style="float: left;">
	<p>Camera control</p>
	<table>
		<tr>
			<td>a</td><td>Camera left</td>
		</tr>
		<tr>
			<td>d</td><td>Camera right</td>
		</tr>
		<tr>
			<td>w</td><td>Camera zoom in</td>
		</tr>
		<tr>
			<td>s</td><td>Camera zoom out</td>
		</tr>
		<tr>
			<td>q</td><td>Camera rotate left</td>
		</tr>
		<tr>
			<td>e</td><td>Camera rotate right</td>
		</tr>
	</table>
</div>
</body>
</html>